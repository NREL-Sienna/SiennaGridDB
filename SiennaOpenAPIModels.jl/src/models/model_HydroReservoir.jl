# This file was generated by the Julia OpenAPI Code Generator
# Do not modify this file directly. Modify the OpenAPI specification instead.

@doc raw"""HydroReservoir

    HydroReservoir(;
        id=nothing,
        name=nothing,
        available=nothing,
        storage_level_limits=nothing,
        initial_level=nothing,
        spillage_limits=nothing,
        inflow=nothing,
        outflow=nothing,
        level_targets=nothing,
        travel_time=nothing,
        intake_elevation=nothing,
        head_to_volume_factor=nothing,
        level_data_type="USABLE_VOLUME",
    )

    - id::Int64
    - name::String
    - available::Bool
    - storage_level_limits::MinMax
    - initial_level::Float64
    - spillage_limits::MinMax
    - inflow::Float64
    - outflow::Float64
    - level_targets::Float64
    - travel_time::Float64
    - intake_elevation::Float64
    - head_to_volume_factor::HeadVolumeFactor
    - level_data_type::String
"""
Base.@kwdef mutable struct HydroReservoir <: OpenAPI.APIModel
    id::Union{Nothing, Int64} = nothing
    name::Union{Nothing, String} = nothing
    available::Union{Nothing, Bool} = nothing
    storage_level_limits = nothing # spec type: Union{ Nothing, MinMax }
    initial_level::Union{Nothing, Float64} = nothing
    spillage_limits = nothing # spec type: Union{ Nothing, MinMax }
    inflow::Union{Nothing, Float64} = nothing
    outflow::Union{Nothing, Float64} = nothing
    level_targets::Union{Nothing, Float64} = nothing
    travel_time::Union{Nothing, Float64} = nothing
    intake_elevation::Union{Nothing, Float64} = nothing
    head_to_volume_factor = nothing # spec type: Union{ Nothing, HeadVolumeFactor }
    level_data_type::Union{Nothing, String} = "USABLE_VOLUME"

    function HydroReservoir(
        id,
        name,
        available,
        storage_level_limits,
        initial_level,
        spillage_limits,
        inflow,
        outflow,
        level_targets,
        travel_time,
        intake_elevation,
        head_to_volume_factor,
        level_data_type,
    )
        o = new(
            id,
            name,
            available,
            storage_level_limits,
            initial_level,
            spillage_limits,
            inflow,
            outflow,
            level_targets,
            travel_time,
            intake_elevation,
            head_to_volume_factor,
            level_data_type,
        )
        OpenAPI.validate_properties(o)
        return o
    end
end # type HydroReservoir

const _property_types_HydroReservoir = Dict{Symbol, String}(
    Symbol("id") => "Int64",
    Symbol("name") => "String",
    Symbol("available") => "Bool",
    Symbol("storage_level_limits") => "MinMax",
    Symbol("initial_level") => "Float64",
    Symbol("spillage_limits") => "MinMax",
    Symbol("inflow") => "Float64",
    Symbol("outflow") => "Float64",
    Symbol("level_targets") => "Float64",
    Symbol("travel_time") => "Float64",
    Symbol("intake_elevation") => "Float64",
    Symbol("head_to_volume_factor") => "HeadVolumeFactor",
    Symbol("level_data_type") => "String",
)
OpenAPI.property_type(::Type{HydroReservoir}, name::Symbol) =
    Union{Nothing, eval(Base.Meta.parse(_property_types_HydroReservoir[name]))}

function OpenAPI.check_required(o::HydroReservoir)
    o.id === nothing && (return false)
    o.name === nothing && (return false)
    o.available === nothing && (return false)
    o.storage_level_limits === nothing && (return false)
    o.initial_level === nothing && (return false)
    o.inflow === nothing && (return false)
    o.outflow === nothing && (return false)
    o.intake_elevation === nothing && (return false)
    o.head_to_volume_factor === nothing && (return false)
    true
end

function OpenAPI.validate_properties(o::HydroReservoir)
    OpenAPI.validate_property(HydroReservoir, Symbol("id"), o.id)
    OpenAPI.validate_property(HydroReservoir, Symbol("name"), o.name)
    OpenAPI.validate_property(HydroReservoir, Symbol("available"), o.available)
    OpenAPI.validate_property(
        HydroReservoir,
        Symbol("storage_level_limits"),
        o.storage_level_limits,
    )
    OpenAPI.validate_property(HydroReservoir, Symbol("initial_level"), o.initial_level)
    OpenAPI.validate_property(HydroReservoir, Symbol("spillage_limits"), o.spillage_limits)
    OpenAPI.validate_property(HydroReservoir, Symbol("inflow"), o.inflow)
    OpenAPI.validate_property(HydroReservoir, Symbol("outflow"), o.outflow)
    OpenAPI.validate_property(HydroReservoir, Symbol("level_targets"), o.level_targets)
    OpenAPI.validate_property(HydroReservoir, Symbol("travel_time"), o.travel_time)
    OpenAPI.validate_property(
        HydroReservoir,
        Symbol("intake_elevation"),
        o.intake_elevation,
    )
    OpenAPI.validate_property(
        HydroReservoir,
        Symbol("head_to_volume_factor"),
        o.head_to_volume_factor,
    )
    OpenAPI.validate_property(HydroReservoir, Symbol("level_data_type"), o.level_data_type)
end

function OpenAPI.validate_property(::Type{HydroReservoir}, name::Symbol, val)
    if name === Symbol("level_data_type")
        OpenAPI.validate_param(
            name,
            "HydroReservoir",
            :enum,
            val,
            ["USABLE_VOLUME", "TOTAL_VOLUME", "HEAD"],
        )
    end
end
