# This file was generated by the Julia OpenAPI Code Generator
# Do not modify this file directly. Modify the OpenAPI specification instead.


@doc raw"""HydroReservoir

    HydroReservoir(;
        id=nothing,
        name=nothing,
        available=nothing,
        storage_level_limits=nothing,
        initial_level=nothing,
        spillage_limits=nothing,
        inflow=nothing,
        outflow=nothing,
        level_targets=nothing,
        intake_elevation=nothing,
        head_to_volume_factor=nothing,
        upstream_turbines=nothing,
        downstream_turbines=nothing,
        upstream_reservoirs=nothing,
        operation_cost=nothing,
        level_data_type="USABLE_VOLUME",
    )

    - id::Int64
    - name::String
    - available::Bool
    - storage_level_limits::MinMax
    - initial_level::Float64
    - spillage_limits::MinMax
    - inflow::Float64
    - outflow::Float64
    - level_targets::Float64
    - intake_elevation::Float64
    - head_to_volume_factor::ValueCurve
    - upstream_turbines::Vector{Int64}
    - downstream_turbines::Vector{Int64}
    - upstream_reservoirs::Vector{Int64}
    - operation_cost::HydroReservoirCost
    - level_data_type::String
"""
Base.@kwdef mutable struct HydroReservoir <: OpenAPI.APIModel
    id::Union{Nothing, Int64} = nothing
    name::Union{Nothing, String} = nothing
    available::Union{Nothing, Bool} = nothing
    storage_level_limits = nothing # spec type: Union{ Nothing, MinMax }
    initial_level::Union{Nothing, Float64} = nothing
    spillage_limits = nothing # spec type: Union{ Nothing, MinMax }
    inflow::Union{Nothing, Float64} = nothing
    outflow::Union{Nothing, Float64} = nothing
    level_targets::Union{Nothing, Float64} = nothing
    intake_elevation::Union{Nothing, Float64} = nothing
    head_to_volume_factor = nothing # spec type: Union{ Nothing, ValueCurve }
    upstream_turbines::Union{Nothing, Vector{Int64}} = nothing
    downstream_turbines::Union{Nothing, Vector{Int64}} = nothing
    upstream_reservoirs::Union{Nothing, Vector{Int64}} = nothing
    operation_cost = nothing # spec type: Union{ Nothing, HydroReservoirCost }
    level_data_type::Union{Nothing, String} = "USABLE_VOLUME"

    function HydroReservoir(id, name, available, storage_level_limits, initial_level, spillage_limits, inflow, outflow, level_targets, intake_elevation, head_to_volume_factor, upstream_turbines, downstream_turbines, upstream_reservoirs, operation_cost, level_data_type, )
        o = new(id, name, available, storage_level_limits, initial_level, spillage_limits, inflow, outflow, level_targets, intake_elevation, head_to_volume_factor, upstream_turbines, downstream_turbines, upstream_reservoirs, operation_cost, level_data_type, )
        OpenAPI.validate_properties(o)
        return o
    end
end # type HydroReservoir

const _property_types_HydroReservoir = Dict{Symbol,String}(Symbol("id")=>"Int64", Symbol("name")=>"String", Symbol("available")=>"Bool", Symbol("storage_level_limits")=>"MinMax", Symbol("initial_level")=>"Float64", Symbol("spillage_limits")=>"MinMax", Symbol("inflow")=>"Float64", Symbol("outflow")=>"Float64", Symbol("level_targets")=>"Float64", Symbol("intake_elevation")=>"Float64", Symbol("head_to_volume_factor")=>"ValueCurve", Symbol("upstream_turbines")=>"Vector{Int64}", Symbol("downstream_turbines")=>"Vector{Int64}", Symbol("upstream_reservoirs")=>"Vector{Int64}", Symbol("operation_cost")=>"HydroReservoirCost", Symbol("level_data_type")=>"String", )
OpenAPI.property_type(::Type{ HydroReservoir }, name::Symbol) = Union{Nothing,eval(Base.Meta.parse(_property_types_HydroReservoir[name]))}

function OpenAPI.check_required(o::HydroReservoir)
    o.id === nothing && (return false)
    o.name === nothing && (return false)
    o.available === nothing && (return false)
    o.storage_level_limits === nothing && (return false)
    o.initial_level === nothing && (return false)
    o.inflow === nothing && (return false)
    o.outflow === nothing && (return false)
    o.intake_elevation === nothing && (return false)
    o.head_to_volume_factor === nothing && (return false)
    o.operation_cost === nothing && (return false)
    true
end

function OpenAPI.validate_properties(o::HydroReservoir)
    OpenAPI.validate_property(HydroReservoir, Symbol("id"), o.id)
    OpenAPI.validate_property(HydroReservoir, Symbol("name"), o.name)
    OpenAPI.validate_property(HydroReservoir, Symbol("available"), o.available)
    OpenAPI.validate_property(HydroReservoir, Symbol("storage_level_limits"), o.storage_level_limits)
    OpenAPI.validate_property(HydroReservoir, Symbol("initial_level"), o.initial_level)
    OpenAPI.validate_property(HydroReservoir, Symbol("spillage_limits"), o.spillage_limits)
    OpenAPI.validate_property(HydroReservoir, Symbol("inflow"), o.inflow)
    OpenAPI.validate_property(HydroReservoir, Symbol("outflow"), o.outflow)
    OpenAPI.validate_property(HydroReservoir, Symbol("level_targets"), o.level_targets)
    OpenAPI.validate_property(HydroReservoir, Symbol("intake_elevation"), o.intake_elevation)
    OpenAPI.validate_property(HydroReservoir, Symbol("head_to_volume_factor"), o.head_to_volume_factor)
    OpenAPI.validate_property(HydroReservoir, Symbol("upstream_turbines"), o.upstream_turbines)
    OpenAPI.validate_property(HydroReservoir, Symbol("downstream_turbines"), o.downstream_turbines)
    OpenAPI.validate_property(HydroReservoir, Symbol("upstream_reservoirs"), o.upstream_reservoirs)
    OpenAPI.validate_property(HydroReservoir, Symbol("operation_cost"), o.operation_cost)
    OpenAPI.validate_property(HydroReservoir, Symbol("level_data_type"), o.level_data_type)
end

function OpenAPI.validate_property(::Type{ HydroReservoir }, name::Symbol, val)
















    if name === Symbol("level_data_type")
        OpenAPI.validate_param(name, "HydroReservoir", :enum, val, ["USABLE_VOLUME", "TOTAL_VOLUME", "HEAD", "ENERGY"])
    end

end
